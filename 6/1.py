# Бинарный поиск — это алгоритм поиска элемента в отсортированном массиве, который работает за логарифмическое время,
# что делает его гораздо более эффективным по сравнению с линейным поиском, особенно для больших массивов.
#
# Принцип работы бинарного поиска следующий:
# Разделение массива: Исходно берём массив и вычисляем индекс центрального элемента.
# Сравнение: Сравниваем центральный элемент с искомым. Если они равны, то поиск завершён.
# Сужение области поиска:
# Если центральный элемент больше искомого,
# то ищем в левой половине массива (все элементы правее центрального исключаются).
# Если центральный элемент меньше искомого,
# то ищем в правой половине массива (все элементы левее центрального исключаются).
# Этот процесс повторяется, каждый раз уменьшая область поиска вдвое,
# пока не будет найден элемент или область поиска не станет пустой.
# Алгоритм продолжает делить массив пополам на каждом шаге, что даёт ему время работы O(log n),
# где n — количество элементов в массиве.

# Императивная парадигма

def binary_search(arr, target):
    # Устанавливаем начальные индексы
    left, right = 0, len(arr) - 1

    while left <= right:
        # Находим индекс центрального элемента
        mid = left + (right - left) // 2

        # Если центральный элемент равен искомому, возвращаем его индекс
        if arr[mid] == target:
            return mid

        # Если центральный элемент больше искомого, ищем в левой половине
        elif arr[mid] > target:
            right = mid - 1

        # Если центральный элемент меньше искомого, ищем в правой половине
        else:
            left = mid + 1

    # Если элемент не найден, возвращаем -1
    return -1


arr = [1, 3, 4, 6, 7, 8, 10, 13, 14]
target = 4
result = binary_search(arr, target)

if result != -1:
    print(f"Элемент найден на индексе: {result}")
else:
    print("Элемент не найден в массиве.")
